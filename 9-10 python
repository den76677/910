1. Блочная сортировка (Bucket Sort)
Python


def bucket_sort(arr):
    """Сортировка распределением по корзинам"""
    if not arr: return arr
    
    # Шаг 1: Создаем корзины
    buckets = [[] for _ in range(len(arr))]
    
    # Шаг 2: Распределяем элементы по корзинам
    for num in arr:
        index = int(num * len(arr))  # Для чисел 0-1
        buckets[index].append(num)
    
    # Шаг 3: Сортируем каждую корзину и объединяем
    return [num for bucket in buckets for num in sorted(bucket)]

# Пример
arr = [0.42, 0.32, 0.33, 0.52, 0.37]
print(bucket_sort(arr))  # [0.32, 0.33, 0.37, 0.42, 0.52]



2. Сортировка бусинами (Bead Sort)
Python


def bead_sort(arr):
    """Гравитационная сортировка для неотрицательных чисел"""
    # Шаг 1: Создаем матрицу бусин
    max_val = max(arr)
    beads = [[1] * num + [0] * (max_val - num) for num in arr]
    
    # Шаг 2: Транспонируем и сортируем строки (гравитация)
    beads_fallen = [sorted(col, reverse=True) for col in zip(*beads)]
    
    # Шаг 3: Считаем бусины в каждом столбце
    return [sum(col) for col in zip(*beads_fallen)]

# Пример
arr = [3, 1, 4, 2]
print(bead_sort(arr))  # [1, 2, 3, 4]





3. Альтернативная сортировка бусинами
Python


def bead_sort_simple(arr):
    """Упрощенная гравитационная сортировка"""
    # Шаг 1: Падаем слева направо
    for i in range(len(arr)):
        for j in range(i + 1, len(arr)):
            if arr[i] > arr[j]:
                arr[i] -= 1
                arr[j] += 1
    
    # Шаг 2: Падаем справа налево  
    for i in range(len(arr)-1, -1, -1):
        for j in range(i-1, -1, -1):
            if arr[i] < arr[j]:
                arr[i] += 1
                arr[j] -= 1
    return arr

# Пример
arr = [2, 4, 1, 3]
print(bead_sort_simple(arr))  # [1, 2, 3, 4]





4. Поиск скачками (Jump Search)
Python


import math

def jump_search(arr, target):
    """Поиск прыжками с фиксированным шагом"""
    n = len(arr)
    step = int(math.sqrt(n))
    
    # Шаг 1: Прыгаем по массиву
    prev = 0
    while arr[min(step, n)-1] < target:
        prev = step
        step += int(math.sqrt(n))
        if prev >= n: return -1
    
    # Шаг 2: Линейный поиск в блоке
    while arr[prev] < target:
        prev += 1
        if prev == min(step, n): return -1
    
    return prev if arr[prev] == target else -1

# Пример
arr = [1, 3, 5, 7, 9, 11, 13]
print(jump_search(arr, 7))  # 3




5. Экспоненциальный поиск (Exponential Search)
Python


def exponential_search(arr, target):
    """Экспоненциальное расширение + бинарный поиск"""
    if not arr: return -1
    
    # Шаг 1: Экспоненциально находим диапазон
    i = 1
    while i < len(arr) and arr[i] < target:
        i *= 2
    
    # Шаг 2: Бинарный поиск в диапазоне
    left, right = i//2, min(i, len(arr)-1)
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target: return mid
        elif arr[mid] < target: left = mid + 1
        else: right = mid - 1
    
    return -1

# Пример
arr = [2, 4, 6, 8, 10, 12, 14, 16]
print(exponential_search(arr, 10))  # 4





6. Тернарный поиск (Ternary Search)
Python


def ternary_search(arr, target):
    """Делим массив на три части"""
    left, right = 0, len(arr)-1
    
    while left <= right:
        # Шаг 1: Делим на три сегмента
        mid1 = left + (right - left) // 3
        mid2 = right - (right - left) // 3
        
        # Шаг 2: Проверяем точки деления
        if arr[mid1] == target: return mid1
        if arr[mid2] == target: return mid2
        
        # Шаг 3: Выбираем сегмент для продолжения
        if target < arr[mid1]:
            right = mid1 - 1
        elif target > arr[mid2]:
            left = mid2 + 1
        else:
            left, right = mid1 + 1, mid2 - 1
    
    return -1

# Пример
arr = [1, 3, 5, 7, 9, 11, 13, 15]
print(ternary_search(arr, 9))  # 4
