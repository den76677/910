1. Блочная сортировка (Bucket Sort)
Python


def bucket_sort(arr):
    if not arr: return arr  # Если массив пустой, возвращаем его
    buckets = [[] for _ in range(len(arr))]  # Создаем пустые корзины
    for num in arr:
        # Распределяем числа по корзинам (для чисел 0-1)
        buckets[int(num * len(arr))].append(num)
    # Сортируем каждую корзину и объединяем результат
    return [num for bucket in buckets for num in sorted(bucket)]





2. Сортировка бусинами (Bead Sort)
Python


def bead_sort(arr):
    max_val = max(arr)  # Находим максимальное число
    # Создаем "бусины": 1 - есть бусина, 0 - нет бусины
    beads = [[1] * num + [0] * (max_val - num) for num in arr]
    # Транспонируем матрицу и сортируем столбцы (бусины падают вниз)
    beads_fallen = [sorted(col, reverse=True) for col in zip(*beads)]
    # Считаем количество бусин в каждом столбце - это отсортированный массив
    return [sum(col) for col in zip(*beads_fallen)]





3. Альтернативная сортировка бусинами
Python


def bead_sort_simple(arr):
    # Первый проход: бусины падают слева направо
    for i in range(len(arr)):
        for j in range(i + 1, len(arr)):
            if arr[i] > arr[j]:
                arr[i] -= 1  # Бусина падает вниз
                arr[j] += 1  # Бусина поднимается вверх
    # Второй проход: бусины падают справа налево
    for i in range(len(arr)-1, -1, -1):
        for j in range(i-1, -1, -1):
            if arr[i] < arr[j]:
                arr[i] += 1
                arr[j] -= 1
    return arr





4. Поиск скачками (Jump Search)
Python


import math

def jump_search(arr, target):
    n = len(arr)
    step = int(math.sqrt(n))  # Размер прыжка = √n
    prev = 0
    # Прыгаем по массиву, пока не найдем блок с target
    while arr[min(step, n)-1] < target:
        prev = step
        step += int(math.sqrt(n))
        if prev >= n: return -1
    # Линейный поиск в найденном блоке
    while arr[prev] < target:
        prev += 1
        if prev == min(step, n): return -1
    return prev if arr[prev] == target else -1




5. Экспоненциальный поиск (Exponential Search)
Python


def exponential_search(arr, target):
    if not arr: return -1
    i = 1
    # Экспоненциально увеличиваем границу поиска
    while i < len(arr) and arr[i] < target:
        i *= 2
    # Бинарный поиск в найденном диапазоне
    left, right = i//2, min(i, len(arr)-1)
    while left <= right:
        mid = (left + right) // 2
        if arr[mid] == target: return mid
        elif arr[mid] < target: left = mid + 1
        else: right = mid - 1
    return -1





6. Тернарный поиск (Ternary Search)
Python


def ternary_search(arr, target):
    left, right = 0, len(arr)-1
    while left <= right:
        # Делим массив на три равные части
        mid1 = left + (right - left) // 3
        mid2 = right - (right - left) // 3
        if arr[mid1] == target: return mid1
        if arr[mid2] == target: return mid2
        # Определяем в какой трети искать
        if target < arr[mid1]: right = mid1 - 1
        elif target > arr[mid2]: left = mid2 + 1
        else: left, right = mid1 + 1, mid2 - 1
    return -1
